---
sidebar_position: 1
---

# REMP Messages

There are three types of messages between nodes in REMP. 

**New messages**

New messages are generated by full nodes at the request of network users. 

Let us say that the network is configured to have N validators per shard.

1. The full node informs validators about the new REMP message. It sends the message to each validator in the current shard, or to each validator in the current shard and to each validator in the next shard **(in case of session switching)**. This results in N or 2N messages.
2. Each validator informs other validators about the new message it received. This results in N^2 messages.

**The first step** is needed to guarantee that at least one of the validators will re-transmit the message **(the full node does not trust validators)**. It is possible to limit their set by N/3+1 random validators **(since we suppose that at most N/3 validators are invalid)**. However, our main optimization goal is to get rid of N^2 in the second step.

**The second step** is needed to guarantee that all validators really received the message. We cannot rely on full node accuracy **(validators do not trust the full node)**.

**Reject/accept messages**

A node informs other nodes that the message is rejected or accepted by the collator. This is necessary for proper ordering of messages in final blocks. Accepted messages should be collated first, while those rejected by 2/3 of collators should not be collated further.

There can be up to N^2 of these messages per external message.

**Forward messages**

Forward messages are generated at the session's end. All validators inform the next validator set about the following messages:

1. The messages that were processed by the validators in the current session **(for replay protection purposes)**
2. The messages that are received but not processed yet

There are N^2 messages in catchain per external message. 

**Proposals for speeding up**

Let us first concentrate on new messages. To reduce traffic, let’s do the following:

1. The full node sends messages sequentially, one by one, with small pauses between them **(100-200 ms)**
2. Validators do not retransmit messages received from the catchain. The catchain guarantees delivery of the messages to all clients. Thus, if at least one node sends the message to the catchain, then everyone will eventually have it.
3. However, if the validator receives the message from the full node and hasn’t received it from the catchain yet, it re-transmits the message to the catchain.

This algorithm guarantees that each network participant will receive the message. The full node sends it to everybody and the nodes retransmit it to others if necessary. However, if the messages are delivered properly, then all nodes, except for the first one, will receive the message from the catchain and will not retransmit it further. So, we have N messages from the full node and one pack of messages re-transmitted via the catchain - 2N..3N messages in total.

Forward messages also have some room for optimization:

1. We need just one forward message in the catchain. Thus, do not forward a message if it is received via the catchain.
2. Only currently processed messages should be delivered in full. Replay protection just needs a hash. The node can send a relatively small pack of hash IDs of other **(processed)** messages.

Reject/accept messages may be removed or limited without any great damage to the protocol if they create too much extra traffic.